#!/usr/bin/env python

from flask import Flask, request, jsonify, copy_current_request_context
from flask_socketio import SocketIO, send, emit
from tools.keysim import Sim 


app = Flask(__name__)
app.config['SEND_FILE_MAX_AGE_DEFAULT'] = 0
socketio = SocketIO(app)

webpage = open("Index_1.html", "r").read()

s = Sim()


import pyscreeze 
import PIL
import os
import base64
from io import BytesIO
import time
from screenshot_optimization import _screenshot_linux_slim as screenshot



@app.route("/")
def index():
    return webpage.encode()



@app.route("/shot")
def handle_screenshot():
    print("[screenshot] stored")
    screenshot()

    return jsonify(msg= "received")

@app.route("/click", methods=["POST"])
def click():
    data = (request.json)
    posx = data["posx"]
    posy = data["posy"]

    s.m.click(posx, posy, 1)
        
    return "received"

@app.route("/scroll", methods=["POST"])
def scroll():

    data = (request.json)
    posx = data["horizontal"]
    posy = data["vertical"]

    print("------")
    print(posx)
    print(posy)
    s.m.scroll(posy, posx)
        
    return "received"



@app.route("/simulate", methods=["POST"])
def simulate():
    data = (request.json)
    val = data["key"]

    print(val)
        
    command = {
            "left": s.pressLeft,
            "right": s.pressRight,
            "up":   lambda: s.tap(s.k.up_key),
            "down":   lambda: s.tap(s.k.down_key),
            }
    selected = command.get(val, lambda: s.k.tap_key(val))

    print(selected())

    return "received"

@app.route("/text", methods=["POST"])
def type():
    data = (request.json)
    val = data["text"]
    print(val)
    print(s.k.type_string(val))
    print(s.k.tap_key("Return"))

    return "received"

#################################
intervals = dict()

@socketio.on('connect')
def handle_connect():
    sid = request.sid
    print(f'[socket][/connect] [{sid}]')

@socketio.on('message')
def handle_message(message):
    print('received message: ' + message)
    send ( "what", broadcast=True )

import threading
stream_timer = None

@socketio.on('stream')
def handle_stream(interval):

    @copy_current_request_context
    def stream_loop():
        global stream_timer
        global intervals
        
        if len(intervals) == 0:
            return

        interval_time = min(intervals.values())/1000
                
        if interval_time == 0:
            return

        import time
        t1 = time.time()
        shot = screenshot()
        if shot == None:
            return
        buffered = BytesIO()
        shot.save(buffered, format="JPEG")
        img_str = base64.b64encode(buffered.getvalue())

        emit ( "image", img_str)

        t2 = time.time()

        elapsed_ms = (t2-t1) * 1000

        print(f"elapsed_ms {elapsed_ms}")

        time_left = (min(intervals.values()) - elapsed_ms)

        stream_timer = threading.Timer( (time_left if time_left >= 0 else 0)/1000, stream_loop)
        stream_timer.start()



    sid = request.sid
    print(f'[socket][/stream] [{sid}] {str(interval)}')
    
    global intervals
    intervals[sid] = interval
    
    if not isinstance (interval, int) or interval == 0:
        del intervals[sid]
        return "Stream OFF"

    #stream_loop()
    thread = socketio.start_background_task(target=stream_loop)
    return "Stream ON"

#################################

def get_ip():
    import socket
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        # doesn't even have to be reachable
        s.connect(('10.255.255.255', 1))
        IP = s.getsockname()[0]
    except:
        IP = '127.0.0.1'
    finally:
        s.close()
    return IP

if __name__ == "__main__":
    import qrcode

    port = 1337
    path = "http://"+(get_ip() + ":" + str(port))+"/"
    img = qrcode.make(path)
    print(f"Remote on {path}")
    img.show()
    img.save(os.path.join("static", "qr.jpeg"), "JPEG")

    #app.run(host= '0.0.0.0', port=port)
    socketio.run(app, host= '0.0.0.0', port=port)
